# Crossing Audit: SQLAlchemy

**Scanned**: SQLAlchemy (latest main branch)
**Date**: February 23, 2026
**Tool**: Crossing v0.9 semantic exception scanner

## Summary

| Metric | Value |
|---|---|
| Files scanned | 661 |
| Exception raises | 1,503 |
| Exception handlers | 630 |
| Semantic crossings | 103 |
| Elevated risk | 31 |
| High risk | 16 |
| Total info loss | 79.8 bits |
| Mean collapse ratio | 43% |

SQLAlchemy has the highest absolute information loss of any project scanned. The raise-to-handler ratio (2.4:1) is inverted from most projects — exceptions are thrown abundantly but caught selectively.

## High-Risk Findings

### 1. `Exception` — 73 raise sites, 58 handlers (83% collapse)

The broadest crossing. `Exception` is raised in 59 different functions across serialization, dialect provisioning, testing infrastructure, and core ORM operations. 58 handlers catch `Exception` from called functions without knowing the raise site. 4.9 bits of information are lost — the handler cannot distinguish a serialization failure from a dialect error from a test infrastructure crash.

**Risk**: High. Bare `Exception` catches are the most dangerous crossing pattern because they collapse the most distinct semantic contexts into a single handler path.

**Recommendation**: Where possible, use specific exception subclasses. SQLAlchemy already has a rich exception hierarchy (`exc.py`) — the issue is that some code paths raise or catch `Exception` directly instead of using it.

### 2. `ValueError` — 57 raise sites, 11 handlers (73% collapse)

`ValueError` is raised in 46 different functions — configuration parsing, SQL compilation, association proxy operations, dialect handling. The 73% collapse ratio means nearly three-quarters of the semantic information is lost when a handler catches `ValueError`.

**Risk**: Medium-high. Most `ValueError` handlers re-raise (good), but the ones that return or handle silently (like `assert_compile` in testing) could mask configuration errors.

### 3. `KeyError` — 61 raise sites, 31 handlers (67% collapse)

Expected for a project with extensive dictionary-based configuration and result mapping. The ORM layer is the densest crossing zone — column lookups, result proxy access, and mapper configuration all raise `KeyError` with different semantic meanings.

### 4. `TypeError` — 29 raise sites, 3 handlers (high risk)

Only 3 handlers for 29 raise sites. The handler-to-raise ratio (1:10) means each handler is responsible for distinguishing 10 different semantic contexts, which it cannot do from the exception type alone.

### 5. `AttributeError` — 37 raise sites, 19 handlers (60% collapse)

Common in the ORM layer where attribute access patterns determine behavior. The `__getattr__`/`__setattr__` machinery raises `AttributeError` in many contexts, and handlers catch it to implement fallback behavior.

## What's Clean

- **Custom exception hierarchy** in `sqlalchemy/exc.py` — SQLAlchemy has invested heavily in specific exception types. The crossings come from stdlib exceptions (`ValueError`, `KeyError`, `TypeError`) rather than from custom types.
- **Re-raise patterns** — Many handlers re-raise (preserving information) rather than silently consuming exceptions.

## Actionable Recommendations

1. **Replace bare `except Exception` handlers** with specific catches where the call tree is known. The 58 broad `Exception` handlers are the lowest-hanging fruit.
2. **Add exception message differentiation** where custom subclasses aren't warranted. A `ValueError("invalid column name")` and a `ValueError("invalid type")` can be distinguished by message, but only if handlers inspect it.
3. **Consider `KeyError` subclasses for ORM operations** — `ColumnNotFoundError(KeyError)` vs `MapperKeyError(KeyError)` would allow handlers to distinguish between lookup failures in different layers.

---

*Generated by [Crossing](https://github.com/Fridayai700/crossing) — semantic exception analysis for Python.*
